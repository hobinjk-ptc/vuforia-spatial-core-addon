<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Frame Screen</title>
    <link rel="stylesheet" type="text/css" href="index.css">
    <link rel="stylesheet" type="text/css" href="crafting.css">
    <link rel="stylesheet" type="text/css" href="memoryExplorer.css">
</head>

<body touch-action="none">

<div id="bg" class="background"></div>
<canvas id="canvas"></canvas>

<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink" style="width: 100vw; height: 100vh; top: 0; left: 0; position:absolute; -webkit-user-select: none; -webkit-touch-callout: none;">
    <polyline id="lasso" stroke-width="5" stroke-linejoin="round" stroke-dasharray="10 4"></polyline>
</svg>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink" id="groupSVG" class="background" style="width: 100vw; height: 100vh; top: 0; left: 0; position:absolute; -webkit-user-select: none; -webkit-touch-callout: none;">
</svg>

<div class='craftingBoardBlur' id="craftingBoard"></div>

<div class="touchOverlay" id="touchOverlay"></div>
<div class="touchOverlay" id="touchOverlaySecondFinger"></div>

<!--<div class="pocket">-->
    <!--<div class="centerVertically" id="pocketScrollContainer">-->
        <!--<div class="palette">-->
        <!--</div>-->
    <!--</div>-->
    <!--<div id="pocketScrollBar"></div>-->
<!--</div>-->

<script src="src/index.js"></script>
<script src="src/constructors.js"></script>
<script src="src/moduleCallbacks.js"></script>

<script src="src/draw.js"></script>
<script src="src/moveabilityOverlay.js"></script>
<script src="src/network.js"></script>
<script src="src/touchEvents.js"></script>
<script src="src/utilities.js"></script>
<script src="src/pocketFrames.js"></script>
<script src="src/pocket.js"></script>
<script src="src/trash.js"></script>
<script src="src/modeToggle.js"></script>
<script src="src/logicNodeInteractions.js"></script>
<script src="src/groupBehavior.js"></script>

<script src="src/frameRenderer.js"></script>
<script src="src/nodeRenderer.js"></script>
<script src="src/linkRenderer.js"></script>
<script src="src/groupRenderer.js"></script>

<script src="src/database.js"></script>

<script src="src/linkingByDrawing.js"></script>
<script src="src/groupingByDrawing.js"></script>

<script src="src/crafting/blockMenu.js"></script>
<script src="src/crafting/eventHandlers.js"></script>
<script src="src/crafting/eventHelper.js"></script>
<script src="src/crafting/grid.js"></script>
<script src="src/crafting/index.js"></script>
<script src="src/crafting/utilities.js"></script>

<script src="src/crafting/craftingBoardMenu.js"></script>

<script src="src/crafting/screenAdapter.js"></script>

<script src="src/objectDiscovery.js"></script>
<script src="src/memoryExplorer.js"></script>
<script src="src/memoryNodeRenderer.js"></script>
<script src="src/memoryLinkRenderer.js"></script>

<script src="/socket.io/socket.io.js"></script>
<script src="resources/pep.min.js"></script>
<script src="resources/hull.js"></script>

<script>
    // var scaleARFactor = 1.5;

    // var scaleRatio = 1;
    var scaleRatio = 3.2107; // gets overridden in utilities.calculateScaleFactor but set to default value here anyways

    var defaultFrameMoveDelay = 400;
    var defaultNodeMoveDelay = 1200;

    // get the url of the reality server to load frames from and to post new frame positions
    var SERVER_IP = location.origin.split(":")[1].split("//")[1];
    var SERVER_PORT = '8080';
    console.log('screen found Reality Server at address:   http://' + SERVER_IP + ':' + SERVER_PORT);

    var tempUuid;

    var frames = {};
    var socket = io();

    var objectName; // receive this from socket
    var targetSize; // receive this from socket

    var windowToEditorRatio = 1;

    // difference between touchscreen is mousemove events trigger regardless of whether clicking down (so need to keep track ourselves)
    var isMouseDown = false;
    var isCurrentGestureSimulated = false;

    // for scaling frames using the touchscreen only
    var firstMouseDown = null;
    var secondMouseDown = null;

    var listenDoubleTap = false;
    var doubleTapTimer = null;
    var listenTripleTap = false;
    var tripleTapTimer = null;

    /**
     * @typedef {Object} EditingState
     * @desc All the necessary state about what's currently being repositioned. Everything else can be calculated from these.
     * @property {string|null} objectKey
     * @property {string|null} frameKey
     * @property {string|null} nodeKey
     * @property {{x: number, y: number}|null} touchOffset
     * @property {boolean} unconstrained
     */

    /**
     * @type {EditingState}
     */
    var editingState = {
        objectKey: null,
        frameKey: null,
        nodeKey: null,
        touchOffset: {
            x: 0,
            y: 0
        }
        // unconstrained: false,
        // unconstrainedOffset: null
    };

    var mouseX = 0;
    var mouseY = 0;

    /**
     * @type {List.<{x: number, y: number, type: string}>}
     */
    var multiTouchList = [];

    var touchEditingTimer = null;

    /**
     * @typedef initialScaleData
     * @property radius {number} how far apart in pixels the two touches are to begin with
     * @property scale {number} the frame or node's initial scale value before the gesture, to use as a base multiplier
     */
    var initialScaleData = null;

    var touchOverlay;
    var touchOverlaySecondFinger;

    var globalCanvas = {};
    globalCanvas.canvas = document.getElementById('canvas');
    globalCanvas.canvas.width = window.innerWidth;
    globalCanvas.canvas.height = window.innerHeight;
    globalCanvas.context = globalCanvas.canvas.getContext('2d');

    window.requestAnimFrame = function(){
        return (
            window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.oRequestAnimationFrame      ||
            window.msRequestAnimationFrame     ||
            function(/* function */ callback){
                window.setTimeout(callback, 1000 / 60);
            }
        );
    }();

    window.onload = function() {

        tempUuid = realityEditor.utilities.uuidTimeShort();

        windowToEditorRatio = Math.max(1, Math.round((window.innerWidth/568)));
        touchOverlay = document.getElementById('touchOverlay');
        touchOverlaySecondFinger = document.getElementById('touchOverlaySecondFinger');

        createTouchOverlay(touchOverlay);
        createTouchOverlay(touchOverlaySecondFinger);

        realityEditor.touchEvents.addTouchListeners();

        realityEditor.network.setupSocketListeners();

        realityEditor.database.initFeature();

        realityEditor.pocket.initFeature();
        realityEditor.trash.initFeature();
        realityEditor.modeToggle.initFeature();

        realityEditor.logicNodeInteractions.initFeature();

        realityEditor.frameRenderer.initFeature();
        realityEditor.nodeRenderer.initFeature();
        realityEditor.linkRenderer.initFeature();
        realityEditor.groupRenderer.initFeature();

        realityEditor.linkingByDrawing.initFeature();

        realityEditor.craftingBoardMenu.initFeature();

        realityEditor.groupingByDrawing.initFeature();
        realityEditor.groupBehavior.initFeature();

        realityEditor.objectDiscovery.initFeature();
        realityEditor.memoryExplorer.initFeature();
        realityEditor.memoryNodeRenderer.initFeature();
        realityEditor.memoryLinkRenderer.initFeature();

        window.addEventListener("message", realityEditor.network.onInternalPostMessage, false);

        // realityEditor.utilities.optimizedResize.add(function() {
        //     console.log(window.innerWidth, window.innerHeight);
        // });

        realityEditor.utilities.optimizedResize.add(realityEditor.utilities.calculateScaleFactor);

        socket.emit('getObjectName');
        socket.emit('getObjectTargetSize');
        socket.emit('getFramesForScreen');
    };

    function createTouchOverlay(objectReference) {
        // objectReference = document.getElementById('touchOverlay');
        objectReference.style.width = (60 * windowToEditorRatio) + 'px';
        objectReference.style.height = (60 * windowToEditorRatio) + 'px';
        objectReference.style.marginLeft = (-30 * windowToEditorRatio) + 'px';
        objectReference.style.marginTop = (-30 * windowToEditorRatio) + 'px';
        objectReference.style.borderRadius = (60 * windowToEditorRatio) + 'px';
        objectReference.style.border = (4 * windowToEditorRatio) + 'px solid #01fffc';
    }

    function getObjectId() {
        if (frames.length === 0) return null;
        var anyFrameId = Object.keys(frames)[0];
        return objectName + anyFrameId.split(objectName)[1].substring(0,12);
    }

    /**
     * Helper function for debugging which frames are in the screen.
     */
    function getScreenFrames() {
        var screenFrames = [];
        for (var frameKey in frames) {
            if (!frames.hasOwnProperty(frameKey)) continue;
            if (frames[frameKey].visualization === 'screen') {
                screenFrames.push(frames[frameKey]);
            }
        }
        return screenFrames;
    }

    /**
     * Helper function for debugging which frames are in AR.
     */
    function getARFrames() {
        var arFrames = [];
        for (var frameKey in frames) {
            if (!frames.hasOwnProperty(frameKey)) continue;
            if (frames[frameKey].visualization === 'ar') {
                arFrames.push(frames[frameKey]);
            }
        }
        return arFrames;
    }

    function getFrameKey(frame) {
        return frame.uuid || frame.objectId + frame.name;
    }

    // ... UTILITIES ... //

    // ........ DOM manipulation ........ //

    /**
     * Utility for converting coordinates from AR space to screen space.
     * @param {number} arX - x coordinate in AR space relative to center of marker.
     * @param {number} arY - y coordinate in AR space relative to center of marker.
     * @return {{x: number, y: number}}
     */
    function getScreenPosFromARPos(arX, arY) {
        var screenCoords = {
            origin: {
                x: 0,
                y: 0
            },
            size: {
                width: window.innerWidth,
                height: window.innerHeight
            }
        };

        var markerCoords = {
            origin: {
                x: targetSize.width/2,
                y: targetSize.height/2
            },
            size: {
                width: targetSize.width,
                height: targetSize.height
            }
        };

        var screenAspectRatio = screenCoords.size.width / screenCoords.size.height;
        var markerAspectRatio = markerCoords.size.width / markerCoords.size.height;

        var screenToMarkerRatio = screenAspectRatio / markerAspectRatio;
        var aspectMultiplier = 1.0 / Math.min(screenToMarkerRatio, 1.0); // if screen is taller than it is wide, scale down the mapping

        if (realityEditor.utilities.isIPad()) {
            aspectMultiplier = 1.0;
        }

        var arPointRelativeToUpperLeft = {
            x: arX + markerCoords.origin.x - screenCoords.origin.x,
            y: arY + markerCoords.origin.y - screenCoords.origin.y
        };

        var screenX = (arPointRelativeToUpperLeft.x) * (screenCoords.size.width / markerCoords.size.width) * (aspectMultiplier);
        var screenY = (arPointRelativeToUpperLeft.y) * (screenCoords.size.width / markerCoords.size.width) * (aspectMultiplier); // use scaleRatio of width for y too because of stretch to fill screen

        return {
            x: screenX,
            y: screenY
        };
    }

    /**
     * Inverse of getScreenPosFromARPos
     * @return {{x: number, y: number}}
     */
    function getARPosFromScreenPos(screenX, screenY) {
        var screenCoords = {
            origin: {
                x: 0,
                y: 0
            },
            size: {
                width: window.innerWidth,
                height: window.innerHeight
            }
        };

        var markerCoords = {
            origin: {
                x: targetSize.width/2,
                y: targetSize.height/2
            },
            size: {
                width: targetSize.width,
                height: targetSize.height
            }
        };

        var screenAspectRatio = screenCoords.size.width / screenCoords.size.height;
        var markerAspectRatio = markerCoords.size.width / markerCoords.size.height;

        var screenToMarkerRatio = screenAspectRatio / markerAspectRatio;
        var aspectMultiplier = 1.0 / Math.min(screenToMarkerRatio, 1.0); // if screen is taller than it is wide, scale down the mapping

        var arX = screenX * (markerCoords.size.width / (screenCoords.size.width * aspectMultiplier)) + screenCoords.origin.x - markerCoords.origin.x;
        var arY = screenY * (markerCoords.size.width / (screenCoords.size.width * aspectMultiplier)) + screenCoords.origin.y - markerCoords.origin.y;

        return {
            x: arX,
            y: arY
        };
    }

    /**
     * Given an x, y coordinate, returns a list of DOM elements intersecting that coordinate
     */
    function getAllDivsUnderCoordinate(x, y) {
        var res = [];
        var previousDisplayTypes = [];

        var ele = document.elementFromPoint(x,y);
        while(ele && ele.tagName !== "BODY" && ele.tagName !== "HTML"){
            res.push(ele);
            // previousDisplayTypes.push(ele.style.display);
            // ele.style.display = "none";
            previousDisplayTypes.push(ele.style.pointerEvents);
            ele.style.pointerEvents = "none";
            ele = document.elementFromPoint(x,y);
        }

        for(var i = 0; i < res.length; i++){
            // res[i].style.display = previousDisplayTypes[i];
            res[i].style.pointerEvents = previousDisplayTypes[i];
        }
        // console.log(res);
        return res;
    }

</script>

</body>
</html>
