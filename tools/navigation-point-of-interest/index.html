<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Navigation Point of Interest</title>
    <script src="objectDefaultFiles/object.js"></script>
    <script src="objectDefaultFiles/pep.min.js"></script>
    <script src="objectDefaultFiles/envelopeContents.js"></script>
    <script src="resources/threejs-src/2016/three.min.js"></script>
    <script src="objectDefaultFiles/gl-worker.js"></script>
</head>
<body>
<script>
    let realRenderer, renderer;
    let realityInterface;
    
    var camera, scene, cube;
    var mainContainerObj, groundplaneContainerObj;
    var mesh;

    let gp_shadow;
    let gp_checkpointDummy;
    let heightLine;

    var isProjectionMatrixSet = false, isGroundPlaneFound = false, isMoving = false;

    var rendererWidth = screen.height;
    var rendererHeight = screen.width;
    var aspectRatio = rendererWidth / rendererHeight;

    var hue = 0.3;
    var saturation = 1;
    var lightness = 0.6;

    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();

    realityInterface = new RealityInterface();
    realityInterface.useWebGlWorker();

    function main() {
        
        console.log('POI MAIN');

        // create a fullscreen webgl renderer for the threejs content and add to the dom
        realRenderer = new THREE.WebGLRenderer({alpha: true});
        realRenderer.setPixelRatio(window.devicePixelRatio);
        realRenderer.setSize(rendererWidth, rendererHeight);
        // document.body.appendChild( realRenderer.domElement );
        realGl = realRenderer.getContext();

        // create a fullscreen webgl renderer for the threejs content and add to the dom
        renderer = new THREE.WebGLRenderer({context: gl, alpha: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(rendererWidth, rendererHeight);
        document.body.appendChild(renderer.domElement);

        realityInterface.getScreenDimensions(function(width, height) {
            document.body.width = width + 'px';
            document.body.height = height + 'px';
            rendererWidth = width;
            rendererHeight = height;
            renderer.setSize( rendererWidth, rendererHeight );

            realityInterface.changeFrameSize(width, height);
        });
    }

    // create a threejs camera and scene
    camera = new THREE.PerspectiveCamera( 70, aspectRatio, 1, 1000 );
    scene = new THREE.Scene();

    // create a parent 3D object to contain all the three js objects
    // we can apply the marker transform to this object and all of its
    // children objects will be affected
    mainContainerObj = new THREE.Object3D();
    mainContainerObj.matrixAutoUpdate = false;
    scene.add(mainContainerObj);

    // Create Ground Plane container
    groundplaneContainerObj = new THREE.Object3D();
    groundplaneContainerObj.matrixAutoUpdate = false;
    groundplaneContainerObj.name = 'groundPlaneContainer';
    scene.add(groundplaneContainerObj);

    // console.log('add cube');
    // var geometrycube = new THREE.BoxGeometry( 10, 10, 10 );
    // var material = new THREE.MeshBasicMaterial( {color: 0xffffff} );
    // cube = new THREE.Mesh( geometrycube, material );
    // mainContainerObj.add( cube );
    // cube.position.set(50,0,0);

    // light the scene with a combination of ambient and directional white light
    var ambLight = new THREE.AmbientLight(0x404040);
    scene.add(ambLight);
    var dirLight1 = new THREE.DirectionalLight(0xffffff, 1);
    dirLight1.position.set(100, 100, 100);
    scene.add(dirLight1);
    var dirLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight2.position.set(-100, -100, -100);
    scene.add(dirLight2);

    // add an icosahedron 3d model to the container object 
    var radius = 75;
    var geometry = new THREE.IcosahedronGeometry( radius, 1 );
    var materials = [
        new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors, shininess: 0 } ),
        new THREE.MeshBasicMaterial( { color: 0x000000, shading: THREE.FlatShading, wireframe: true, transparent: true } )
    ];
    mesh = THREE.SceneUtils.createMultiMaterialObject( geometry, materials );
    mainContainerObj.add( mesh );
    //mesh.position.setZ(150);

    // add spotlight for the shadows
    var spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(-30, -30, 150);
    spotLight.castShadow = true;
    mesh.add(spotLight);

    // Allow this tool to be accepted by envelopes by instantiating an EnvelopeContents
    let envelopeContents = new EnvelopeContents(realityInterface, document.body);

    envelopeContents.onMessageFromEnvelope(function(envelopeMessage) {
        
        if (typeof envelopeMessage.highlightTarget !== 'undefined') {
            if (envelopeMessage.highlightTarget) {

                //console.log('HIGHLIGHT TARGET!');
                
                // document.getElementById('container').style.borderColor = 'cyan';
                lightness = 0.6;
                saturation = 1.0;
            } else {

                //console.log('UNHIGHLIGHT TARGET!');
                
                // document.getElementById('container').style.borderColor = '';
                lightness = 0.9;
                saturation = 0.6;
            }
        }
    });

    realityInterface.onRealityInterfaceLoaded(function() {

        realityInterface.subscribeToMatrix();
        realityInterface.setFullScreenOn();

        // whenever we receive new matrices from the editor, update the 3d scene
        realityInterface.addMatrixListener(renderScene);

        realityInterface.setMoveDelay(10);

        realityInterface.registerTouchDecider(touchDecider);

        realityInterface.addGroundPlaneMatrixListener(groundPlaneCallback);

        realityInterface.addIsMovingListener(function(e) {
            if (e) {
                console.log('PoI is moving');
                // hue = 0.3;
                saturation = 1;
                // lightness = 0.75;
                isMoving = true;
            } else {
                console.log('PoI is NOT moving');
                // hue = 0;
                saturation = 0.75;
                // lightness = 0.6;
                isMoving = false;
            }
        });
        
    });
    
    setTimeout(function(){ addShadowAndHeightLine(); }, 3000);   // This is needed to avoid the initial setup frames where matrices are empty

    

    function touchDecider(eventData) {
        //1. sets the mouse position with a coordinate system where the center
        //   of the screen is the origin
        mouse.x = ( eventData.x / window.innerWidth ) * 2 - 1;
        mouse.y = - ( eventData.y / window.innerHeight ) * 2 + 1;
        
        //2. set the picking ray from the camera position and mouse coordinates
        raycaster.setFromCamera( mouse, camera );
        
        //3. compute intersections
        var intersects = raycaster.intersectObjects( scene.children, true );

        return intersects.length > 0;
    }

    function setMatrixFromArray(matrix, array) {
        matrix.set( array[0], array[4], array[8], array[12],
            array[1], array[5], array[9], array[13],
            array[2], array[6], array[10], array[14],
            array[3], array[7], array[11], array[15]
        );
    }

    let lastProjectionMatrix = null;
    let lastModelViewMatrix = null;

    function renderScene(modelViewMatrix, projectionMatrix) {

        lastProjectionMatrix = projectionMatrix;
        lastModelViewMatrix = modelViewMatrix;
    }

    function groundPlaneCallback(groundPlaneMatrix, projectionMatrix){
        if (isProjectionMatrixSet) {
            isGroundPlaneFound = true;
            setMatrixFromArray(groundplaneContainerObj.matrix, groundPlaneMatrix);  // update model view matrix
        }
    }

    function addShadowAndHeightLine(){

        // Floor Mark

        let texture = new THREE.TextureLoader().load( "resources/textures/checkpointFloor.png" );
        let planeGeometry = new THREE.PlaneGeometry( 10, 10, 32 );
        let planeMaterial = new THREE.MeshBasicMaterial( {color: 0xffffff, opacity: 1.0, transparent: true, side: THREE.DoubleSide, map : texture} );
        gp_shadow = new THREE.Mesh( planeGeometry, planeMaterial );
        gp_shadow.rotateX(Math.PI/2);


        var geometry1 = new THREE.SphereGeometry( 3, 32, 32 );
        var material1 = new THREE.MeshBasicMaterial( {color: 0xffff00, transparent: true, opacity: 0} );
        gp_checkpointDummy = new THREE.Mesh( geometry1, material1 );

        mesh.add(gp_shadow);
        gp_shadow.position.set(0,0,0);
        
        mesh.add(gp_checkpointDummy);
        THREE.SceneUtils.attach( gp_shadow, mesh, groundplaneContainerObj );

        gp_shadow.scale.set(5,5,5);

        // Height line

        let positionCheckpoint = new THREE.Vector3(0,0,0);
        mesh.getWorldPosition(positionCheckpoint);
        
        var material = new THREE.LineBasicMaterial({
            color: 0x0000ff
        });

        heightLine = new THREE.Geometry();
        heightLine.vertices.push(
            gp_shadow.position,
            gp_shadow.position);
        heightLine.verticesNeedUpdate = true;

        var line = new THREE.Line(heightLine, new THREE.LineBasicMaterial({
            color: 0xffffff
        }));

        groundplaneContainerObj.add(line);

        if (isGroundPlaneFound) updateShadow();
    }

    // Update shadow, update height line
    function updateShadow(){

        if (gp_shadow && heightLine) {

            const gp_meshPos = new THREE.Vector3();
            //mainContainerObj.localToWorld(gp_meshPos);
            mesh.getWorldPosition(gp_meshPos);
            groundplaneContainerObj.worldToLocal(gp_meshPos);

            gp_shadow.position.set(gp_meshPos.x, 0, gp_meshPos.z);
            gp_shadow.rotation.set(Math.PI/2,0,0);
            
            let meshPosition = new THREE.Vector3(gp_meshPos.x, gp_meshPos.y - 50, gp_meshPos.z);

            heightLine.vertices = [];
            heightLine.vertices.push(
                gp_shadow.position,
                meshPosition);
            heightLine.verticesNeedUpdate = true;
            
        }
    }

    let _then = 0;
    let done = false;
    
    render = function(_now) {
        
        console.log('HOLAAAAAA RENDER POI');
        
        // only set the projection matrix for the camera 1 time, since it stays the same
        if (!isProjectionMatrixSet && lastProjectionMatrix && lastProjectionMatrix.length === 16) {
            setMatrixFromArray(camera.projectionMatrix, lastProjectionMatrix);
            isProjectionMatrixSet = true;
        }

        if (isProjectionMatrixSet && lastModelViewMatrix && lastModelViewMatrix.length === 16) { // don't turn into else statement, both can happen
            // update models with newest values from the reality editor
            mesh.children[0].material.color.setHSL( hue, saturation, lightness );
            mesh.rotation.x += 0.005; // slow rotation, for aesthetic effect
            mesh.rotation.y += 0.01;
            // update model view matrix
            setMatrixFromArray(mainContainerObj.matrix, lastModelViewMatrix);
            // render the scene
            mainContainerObj.visible = true;

            //renderer.render( scene, camera );

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
                if (done && realGl) {
                    for (let proxy of proxies) {
                        proxy.__uncloneableObj = null;
                        delete proxy.__uncloneableObj;
                    }
                    proxies = [];
                    realRenderer.dispose();
                    realRenderer.forceContextLoss();
                    realRenderer.context = null;
                    realRenderer.domElement = null;
                    realRenderer = null;
                    realGl = null;
                }
                done = true;
            }
        }
        
        if (isGroundPlaneFound && isMoving){
            updateShadow();
        }
    }

</script>
</body>
</html>
